/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>
#include <time.h>

#define REP(i, x, y) for (int i = (x); i < (y); i++)
#define RREP(i, x, y) for (int i = (y)-1; i >= (x); i--)
#define all(x) (x).begin(), (x).end()
//#define int long long

using namespace std;

// conversion
inline int toInt(string s)
{
    int v;
    istringstream sin(s);
    sin >> v;
    return v;
}
template <class T>
inline string toString(T x)
{
    ostringstream sout;
    sout << x;
    return sout.str();
}

#define dump(x) cout << #x << " = " << (x) << endl
#define debug(x) cout << #x << " = " << (x) << " (L" << __LINE__ << ")" \
                      << " " << __FILE__ << endl

typedef long long ll;

const ll MOD = 1e9 + 7;

class CDominoQuality
{
    bool getPattern(const int N, const int quality, int X, int Y, vector<vector<char>> &grids)
    {
        assert(N <= 7);
        // initialize
        if (grids.empty())
        {
            grids = vector<vector<char>>(N, vector<char>(N, '.'));
        }

        /*
        // validate grids
        REP(y, 0, N)
        {
            int q = 0;
            REP(x, 0, N)
            {
                if (grids[y][x] != '.' && (x == 0 || grids[y][x - 1] != grids[y][x]))
                    q++;
            }
            if (q > quality)
                return false;
        }
        // validate all columns
        REP(x, 0, N)
        {
            int q = 0;
            REP(y, 0, N)
            {
                if (grids[y][x] != '.' && (y == 0 || grids[y - 1][x] != grids[y][x]))
                    q++;
            }
            if (q > quality)
                return false;
        }
        */

        // go to next row
        if (X == N)
        {
            // validate row
            int q = 0;
            REP(x, 0, N)
            {
                if (grids[Y][x] != '.' && (x == 0 || grids[Y][x - 1] != grids[Y][x]))
                    q++;
            }
            if (q != quality)
                return false;
            X = 0;
            Y++;
        }

        // validate
        if (X == Y && X == N - 1)
        {
            // validate all rows
            REP(y, 0, N)
            {
                int q = 0;
                REP(x, 0, N)
                {
                    if (grids[y][x] != '.' && (x == 0 || grids[y][x - 1] != grids[y][x]))
                        q++;
                }
                if (q != quality)
                    return false;
            }
            // validate all columns
            REP(x, 0, N)
            {
                int q = 0;
                REP(y, 0, N)
                {
                    if (grids[y][x] != '.' && (y == 0 || grids[y - 1][x] != grids[y][x]))
                        q++;
                }
                if (q != quality)
                    return false;
            }

            return true;
        }

        // put vertical domino
        if (Y < N - 1 && grids[Y][X] == '.' && grids[Y + 1][X] == '.')
        {
            grids[Y][X] = 'a' + (Y % 3) + 3 * (X % 3);
            grids[Y + 1][X] = 'a' + (Y % 3) + 3 * (X % 3);
            if (getPattern(N, quality, X + 1, Y, grids))
                return true;
            grids[Y][X] = '.';
            grids[Y + 1][X] = '.';
        }

        // put horizontal domino
        if (X < N - 1 && grids[Y][X] == '.' && grids[Y][X + 1] == '.')
        {
            grids[Y][X] = 'a' + (Y % 3) + 3 * (X % 3);
            grids[Y][X + 1] = 'a' + (Y % 3) + 3 * (X % 3);
            if (getPattern(N, quality, X + 1, Y, grids))
                return true;
            grids[Y][X] = '.';
            grids[Y][X + 1] = '.';
        }

        // put nothing
        if (getPattern(N, quality, X + 1, Y, grids))
            return true;

        return false;
    }

public:
    void solve(std::istream &in, std::ostream &out)
    {
        int N;
        in >> N;
        vector<vector<char>> grids3, grids4, grids5, grids6, grids7;
        getPattern(3, 2, 0, 0, grids3);
        getPattern(4, 3, 0, 0, grids4);
        getPattern(5, 3, 0, 0, grids5);
        getPattern(6, 3, 0, 0, grids6);
        getPattern(7, 3, 0, 0, grids7);
        vector<vector<char>> grids(N, vector<char>(N, '.'));
        if (N <= 2)
        {
            out << -1 << "\n";
            return;
        }
        auto fill = [&](const int X, const int Y, const vector<vector<char>> &pattern, vector<vector<char>> &grids) {
            REP(y, 0, pattern.size())
            {
                REP(x, 0, pattern.size())
                {
                    grids[y + Y][x + X] = pattern[y][x];
                }
            }
        };
        if (N == 3)
        {
            grids = grids3;
        }
        else
        {
            int y = 0, x = 0;
            while (N - y >= 4)
            {
                if (N - x == 5)
                {
                    fill(x, y, grids5, grids);
                    x += 5;
                }
                else if (N - x == 6)
                {
                    fill(x, y, grids6, grids);
                    x += 6;
                }
                else if (N - x == 7)
                {
                    fill(x, y, grids7, grids);
                    x += 7;
                }
                else
                {
                    fill(x, y, grids4, grids);
                }
                x += 4;
                y += 4;
            }
        }
        REP(y, 0, grids.size())
        {
            REP(x, 0, grids.size())
            {
                out << grids[y][x];
            }
            out << "\n";
        }
    }

public:
    void tmp(std::ostream &out)
    {
        vector<vector<char>> grids;
        getPattern(7, 3, 0, 0, grids);

        REP(y, 0, grids.size())
        {
            REP(x, 0, grids.size())
            {
                out << grids[y][x];
            }
            out << "\n";
        }

        return;
    }
};

int main()
{
    CDominoQuality solver;
    // std::istream &in(std::cin);
    std::ostream &out(std::cout);
    clock_t start = clock();
    solver.tmp(out);
    clock_t end = clock();
    const double time = static_cast<double>(end - start) / CLOCKS_PER_SEC * 1000.0;
    printf("time %lf[ms]\n", time);
    return 0;
}
